Spring Batch의 chunk 방식:
Read → Process → Write 를 계속 반복하면서 대량 데이터를 조금씩(Chunk) 처리하는 패턴

1. 전체 흐름

chunk(10) 이라고 하면
 1) Reader가 데이터 10건을 “읽고”
 2) 그 10건을 하나씩 Processor로 보내서 가공/검증하고
 3) 가공이 끝난 10건(or 그 중 유효한 것들)을 한 번에 Writer로 넘겨서 저장

이 1~3을 데이터가 끝날 때까지 반복
즉, [읽고 10개 모으기] → [10개 가공] → [10개 저장(트랜잭션 커밋)] → 다시 반복


2. Reader – “어디서 데이터를 가져올까?” (입구, 창고 담당)

    데이터 소스에서 한 건씩 Item을 꺼내오는 역할
    “읽기 전용”에 집중, 비즈니스 로직은 최대한 넣지 않기

    공장 비유: 창고에서 박스를 하나씩 컨베이어 벨트에 올려놓는 역할


3. Processor – “읽어온 걸 어떻게 해석·가공할까?” (작업자, 검수+가공 담당)

    Reader가 읽어온 원본 데이터를 → 비즈니스 로직에 맞게 가공/검증/필터링하는 역할
    핵심 비즈니스 로직이 들어가는 자리

    공장 비유 : 컨베이어 벨트 위의 박스를 열어보고 불량품은 버리고(skip) 멀쩡한 건 포장하기 좋은 상태로 정리해주는 “작업자” 역할


4. Writer – “가공된 결과를 어디에, 어떻게 저장할까?” (출고/저장 담당)

    Processor에서 가공된 Item들을 모아서 "목적지"로 저장하는 역할
    DB Insert/Update, 파일 쓰기, 외부 API로 대량 전송 등

    중요 포인트: Reader는 "한 건씩" 반환하지만, Writer는 "Chunk 단위(List)"로 받는다.
    즉, chunk(10)이면 Writer는 매번 10개 리스트를 하나로 받아서 처리하고, 그 단위로 트랜잭션 커밋.
    Reader → Processor 까지는 하나씩 Writer는 List를 받아서 JPA로 한 번에 저장 (트랜잭션 하나)

    공장 비유 : 가공 완료된 제품 10개를 한 박스에 모아서 출고하거나 창고에 넣는 역할

6. Holiday-Keeper 에서의 사용

    Reader -> (year, country) 목록, 또는 Nager API에서 원본 데이터 읽기

    Processor -> Nager API 호출 → Holiday 엔티티 리스트로 변환, 잘못된 타입/데이터 검증

    Writer -> 기존 연도+국가 삭제 → 새 Holiday 엔티티 insert